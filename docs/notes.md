# How to use ShadCN

```tsx
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

export default function Home1(){
  const temp : boolean = true ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <Button variant="outline">Click Me</Button>
    </div>
  )
}

export  function Home2(){
  const temp : boolean = true ; 
  return (
    // Applying multiple conditional tailwind classes to a element (here div)
    <div className={cn("text-amber-700 font-extrabold",temp && "text-green-500")}>
      Welcome to the Home Page
    </div>
  )
}
```


## Using TRPC in NextJs

# Adding TRPC in layout.tsx
```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { TRPCReactProvider } from "@/trpc/client";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`} >
        <TRPCReactProvider>
          {children}
        </TRPCReactProvider>
      </body>
    </html>
  );
}

```

# TRPC Procedures vs Express Routes
in express we call the routes through fetch or axios 
but 
in trpc we call the procedure directly as a function

baseProcedure is used to create endpoints / routes
.query -> get api call
.mutation -> post api call


1) **Express**
``` ts 
// EXPRESS - Manual everything
app.get('/api/user/:id', (req, res) => {
  const id = req.params.id; // ❌ No type safety
  // ... logic
  res.json({ user: data }); // ❌ No type checking
});

// Client
const res = await fetch('/api/user/123');
const data = await res.json(); // ❌ No idea what shape this is

```


2) **TRPC**
```ts

// TRPC - Automatic type safety
userById: baseProcedure
  .input(z.object({ id: z.string() })) // ✅ Validated input
  .query(({ input }) => {
    return { user: data }; // ✅ Type-checked output
  })

// Client
const data = await trpc.userById.query({ id: '123' }); // ✅ Fully typed!

```


# Proper Way of Fetching Data from TRPC

1) Server Component

**NOTE** : caller is `server-only`  i.e can only be used in server components 

```tsx
import { caller } from "@/trpc/server";

export default async function Home1(){
  const users = await caller.getUsers() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <div> {JSON.stringify(users)}</div>
    </div>
  )
}
```

2) Client Component

**Method 1**

```tsx
"use client"
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

export default  function Home(){
  const trpc = useTRPC() ;
  const { data : users } = useQuery(trpc.getUsers.queryOptions())
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <div> {JSON.stringify(users)}</div>
    </div>
  )
}
```

**Method 2** : Passing Data from Server Component to Client Component

-> let page.tsx be server component by default
-> create a new file client.tsx for client component

* Disadvantage : only the data will be fetched on server side, any further data fetching or interaction will not be possible on client side

client.tsx
----------

```tsx
"use client" ; 

export const Client = ({ users } : { users : Record<string,any>[] } ) =>{
    return (
        <div>
            Client Component : {JSON.stringify(users)}
        </div>
    )
}
```


page.tsx
--------

```tsx
import { caller } from "@/trpc/server";
import { Client } from "./client";

export default async function Home(){
  const users : Record<string,any>[] = await caller.getUsers() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <Client users = {users} />
    </div>
  )
}
```

3) **PREFERRED METHOD** :  Creating Boundary between Server and Client Component

page.tsx
--------

```tsx
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import { Suspense } from "react";
import { Client } from "./client";
import { getQueryClient , trpc} from "@/trpc/server";

export default  function Home(){
  const queryClient = getQueryClient() ;
  void  queryClient.prefetchQuery(trpc.getUsers.queryOptions()) ; // leveraging the speed of an Server Component by prefetching the data

  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <HydrationBoundary state={dehydrate(queryClient)}>
         <Suspense fallback={ <div>Loading...</div> }>
           <Client/>
         </Suspense>
      </HydrationBoundary>
    </div>
  )
}
```


client.tsx
----------
```tsx
"use client" ;
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";

export const Client = () => {
    const trpc = useTRPC() ;
    const {data : users} = useSuspenseQuery(trpc.getUsers.queryOptions()) ;  // this will return multiple properties 
    return (
        <div>
            Client Component : {JSON.stringify(users)}
        </div>
    )
}

```


# Better Auth 

1) email and password authentication

```tsx
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import  pClient from "./db";

export const auth = betterAuth({
    database: prismaAdapter(pClient, {
        provider: "postgresql", // or "mysql", "postgresql", ...etc
    }),
    emailAndPassword : {
        enabled: true
    }
});
```


# To use toast in NextJs
-> toast module is used to display temporary messages/popups to the user
-> add the <Toaster/> in layout.tsx

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { TRPCReactProvider } from "@/trpc/client";
import { Toaster } from "sonner";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`} >
        <TRPCReactProvider>
          {children}
          <Toaster/>
        </TRPCReactProvider>
      </body>
    </html>
  );
}
```

Example of using better-auth in NextJs client component
```tsx
"use client"
import { authClient } from "@/lib/auth-client"
import { Button } from "@/components/ui/button"

export default function Home(){
  const { data } = authClient.useSession() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      {JSON.stringify(data)}
      { 
        data 
        && 
        <Button onClick= {() => authClient.signOut()}>
        SignOut
      </Button>
      }
    </div>
  )
}
```

**NOTE : In NextJs the middleware are not used for security purposes but for user experience as a proxy , the security should be implemented using TRPC protected procedures which is present in DATA ACCESS LAYER.**

# AUTH using better-auth 

auth-utils.ts  (src/lib/auth-utils.ts)
-------------
```tsx
import { headers } from "next/headers";
import { redirect } from "next/navigation";
import { auth } from "./auth";

export const requireAuth = async() => {   // ensures that only authenticated users can access certain pages
    const session = await auth.api.getSession({
        headers : await headers() ,
    })
    
    if(!session){
        redirect("/login") ;
    }
    return session ; 
}

export const requireUnauth = async() => {   // ensures that only unauthenticated users can access certain pages
    const session = await auth.api.getSession({
        headers : await headers() ,
    })
    if(session){
        redirect("/") ;
    }
    return session ; 
}
```

page.tsx (src/app/page.tsx)
--------

```tsx 
import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/auth-client";
import { requireAuth } from "@/lib/auth-utils";
import { caller } from "@/trpc/server";
import { LogOutButton } from "./logout";

const Home = async() => {
  await requireAuth() ;  // for User Experience , the real auth check is done in trpc protected procedures
  const data = await caller.getWorkFlows()
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center flex-col gap-y-6">
      protected server component
      <div>
        {JSON.stringify(data,null,2)}
      </div>
        <LogOutButton/>
    </div>
  )
}

export default Home ;
```


# Adding Protected Procedures in TRPC

init.ts (src/trpc/init.ts)
-------

```tsx
export const protectedProcedure = baseProcedure.use(async({ ctx , next}) => {
  // check if the user is signed in
  const session  = await auth.api.getSession({
    headers : await headers()
  }) ;

  if(!session){
    throw new TRPCError({
      code : 'UNAUTHORIZED',
      message : 'User is not authenticated' 
    })
  }
  return next({ ctx : {...ctx , auth : session }}) ; 
```


# .query() vs .mutation()

* .query() -> Fetch/read data without changing anything
* .mutation() -> create / update / delete data

```ts
export const appRouter = createTRPCRouter({
  getWorkFlows : protectedProcedure.query(({ctx}) => {     
      return pClient.workflow.findMany();
  }), 
  createWorkFlow : protectedProcedure.mutation(() => {    
     return pClient.workflow.create({
        data : {
          name : "test-workflow"
        }
     })
  }),
});
// export type definition of API
export type AppRouter = typeof appRouter;
```


* These tanstack react query hooks are used in client component and can execute the promises

-> useQuery for .query()  
-> useMutation for .mutation()

page.tsx (src/app/page.tsx)
--------
```tsx
"use client" ;

import { Button } from "@/components/ui/button";
import { LogOutButton } from "./logout";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useTRPC } from "@/trpc/client";

const Home = () => {
    const  trpc = useTRPC() ; 
    const { data } = useQuery(trpc.getWorkFlows.queryOptions()) ;

    const queryClient = useQueryClient() ; 
    const create = useMutation(trpc.createWorkFlow.mutationOptions({
      onSuccess : () => {
        queryClient.invalidateQueries(trpc.getWorkFlows.queryOptions()) ;  // refetchs data/worklow in case of successul creation
      }
    })) ;

  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center flex-col gap-y-6">
      protected server component
      <div>
        {JSON.stringify(data,null,2)}
      </div>
      <Button disabled={create.isPending} onClick={ () => create.mutate() }>
        Create workflow
      </Button>

      <LogOutButton/>
    </div>
  )
}

export default Home ;
```


# BackGround Jobs

1) Invoking background job through inngest by code 

* using .send() method 

```tsx
    await inngest.send({
      name : "test/hello.world" ,    // event name 
      data : {
        email : "test1123gmail.com"
      },
    }) ;

```

**NOTE** : can be done manually from inngest dashboard
