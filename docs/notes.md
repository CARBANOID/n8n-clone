# How to use ShadCN

```tsx
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

export default function Home1(){
  const temp : boolean = true ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <Button variant="outline">Click Me</Button>
    </div>
  )
}

export  function Home2(){
  const temp : boolean = true ; 
  return (
    // Applying multiple conditional tailwind classes to a element (here div)
    <div className={cn("text-amber-700 font-extrabold",temp && "text-green-500")}>
      Welcome to the Home Page
    </div>
  )
}
```


## Using TRPC in NextJs (https://trpc.io/docs/client/tanstack-react-query/server-components)

# Adding TRPC in layout.tsx
```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { TRPCReactProvider } from "@/trpc/client";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`} >
        <TRPCReactProvider>
          {children}
        </TRPCReactProvider>
      </body>
    </html>
  );
}

```

# TRPC Procedures vs Express Routes
in express we call the routes through fetch or axios 
but 
in trpc we call the procedure directly as a function

baseProcedure is used to create endpoints / routes
.query -> get api call
.mutation -> post api call


1) **Express**
``` ts 
// EXPRESS - Manual everything
app.get('/api/user/:id', (req, res) => {
  const id = req.params.id; // ❌ No type safety
  // ... logic
  res.json({ user: data }); // ❌ No type checking
});

// Client
const res = await fetch('/api/user/123');
const data = await res.json(); // ❌ No idea what shape this is

```


2) **TRPC**
```ts

// TRPC - Automatic type safety
userById: baseProcedure
  .input(z.object({ id: z.string() })) // ✅ Validated input
  .query(({ input }) => {
    return { user: data }; // ✅ Type-checked output
  })

// Client
const data = await trpc.userById.query({ id: '123' }); // ✅ Fully typed!

```

# How to create Procedures in TRPC using TRPC router

```tsx
import { createTRPCRouter } from "@/trpc/init";
export const workflowsRouter = createTRPCRouter({
// define procedures here
  getWorkFlows : protectedProcedure.query(({ctx}) => {   
      return pClient.workflow.findMany();
  }), 
}) ;
```

Example 
------
```ts
import pClient from "@/lib/db";
import { createTRPCRouter, protectedProcedure } from "@/trpc/init";
import { z } from "zod";

export const workflowsRouter = createTRPCRouter({
    remove : protectedProcedure
        .input(z.object({    // expected request body 
            id : z.string()
        }))
        .mutation(async( { ctx , input }) =>{  // accessing the request body through input
        return pClient.workflow.delete({
            where : {
                id : input.id ,
                userId : ctx.auth.user.id 
            }
        })
    })
}) ;

```


# Proper Way of Fetching Data from TRPC

1) Server Component

**NOTE** : caller is `server-only`  i.e can only be used in server components 

```tsx
import { caller } from "@/trpc/server";

export default async function Home1(){
  const users = await caller.getUsers() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <div> {JSON.stringify(users)}</div>
    </div>
  )
}
```

2) Client Component

**Method 1**

```tsx
"use client"
import { useTRPC } from "@/trpc/client";
import { useQuery } from "@tanstack/react-query";

export default  function Home(){
  const trpc = useTRPC() ;
  const { data : users } = useQuery(trpc.getUsers.queryOptions())
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <div> {JSON.stringify(users)}</div>
    </div>
  )
}
```

**Method 2** : Passing Data from Server Component to Client Component

-> let page.tsx be server component by default
-> create a new file client.tsx for client component

* Disadvantage : only the data will be fetched on server side, any further data fetching or interaction will not be possible on client side

client.tsx
----------

```tsx
"use client" ; 

export const Client = ({ users } : { users : Record<string,any>[] } ) =>{
    return (
        <div>
            Client Component : {JSON.stringify(users)}
        </div>
    )
}
```


page.tsx
--------

```tsx
import { caller } from "@/trpc/server";
import { Client } from "./client";

export default async function Home(){
  const users : Record<string,any>[] = await caller.getUsers() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <Client users = {users} />
    </div>
  )
}
```

3) **PREFERRED METHOD** :  Creating Boundary between Server and Client Component

* using prefetch() in server component to prefetch the data
* using useSuspenseQuery() in client component to use the prefetched data

page.tsx
--------

```tsx
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import { Suspense } from "react";
import { Client } from "./client";
import { getQueryClient , trpc} from "@/trpc/server";

export default  function Home(){
  const queryClient = getQueryClient() ;
  void  queryClient.prefetchQuery(trpc.getUsers.queryOptions()) ; // leveraging the speed of an Server Component by prefetching the data

  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      <HydrationBoundary state={dehydrate(queryClient)}>
         <Suspense fallback={ <div>Loading...</div> }>
           <Client/>
         </Suspense>
      </HydrationBoundary>
    </div>
  )
}
```


client.tsx
----------
```tsx
"use client" ;
import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";

export const Client = () => {
    const trpc = useTRPC() ;
    const {data : users} = useSuspenseQuery(trpc.getUsers.queryOptions()) ;  // this will return multiple properties 
    return (
        <div>
            Client Component : {JSON.stringify(users)}
        </div>
    )
}

```


# Better Auth 

1) email and password authentication

```tsx
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import  pClient from "./db";

export const auth = betterAuth({
    database: prismaAdapter(pClient, {
        provider: "postgresql", // or "mysql", "postgresql", ...etc
    }),
    emailAndPassword : {
        enabled: true
    }
});
```


# To use toast in NextJs
-> toast module is used to display temporary messages/popups to the user
-> add the <Toaster/> in layout.tsx

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { TRPCReactProvider } from "@/trpc/client";
import { Toaster } from "sonner";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`} >
        <TRPCReactProvider>
          {children}
          <Toaster/>
        </TRPCReactProvider>
      </body>
    </html>
  );
}
```

Example of using better-auth in NextJs client component
```tsx
"use client"
import { authClient } from "@/lib/auth-client"
import { Button } from "@/components/ui/button"

export default function Home(){
  const { data } = authClient.useSession() ; 
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center">
      {JSON.stringify(data)}
      { 
        data 
        && 
        <Button onClick= {() => authClient.signOut()}>
        SignOut
      </Button>
      }
    </div>
  )
}
```

**NOTE : In NextJs the middleware are not used for security purposes but for user experience as a proxy , the security should be implemented using TRPC protected procedures which is present in DATA ACCESS LAYER.**

# AUTH using better-auth 

auth-utils.ts  (src/lib/auth-utils.ts)
-------------
```tsx
import { headers } from "next/headers";
import { redirect } from "next/navigation";
import { auth } from "./auth";

export const requireAuth = async() => {   // ensures that only authenticated users can access certain pages
    const session = await auth.api.getSession({
        headers : await headers() ,
    })
    
    if(!session){
        redirect("/login") ;
    }
    return session ; 
}

export const requireUnauth = async() => {   // ensures that only unauthenticated users can access certain pages
    const session = await auth.api.getSession({
        headers : await headers() ,
    })
    if(session){
        redirect("/") ;
    }
    return session ; 
}
```

page.tsx (src/app/page.tsx)
--------

```tsx 
import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/auth-client";
import { requireAuth } from "@/lib/auth-utils";
import { caller } from "@/trpc/server";
import { LogOutButton } from "./logout";

const Home = async() => {
  await requireAuth() ;  // for User Experience , the real auth check is done in trpc protected procedures
  const data = await caller.getWorkFlows()
  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center flex-col gap-y-6">
      protected server component
      <div>
        {JSON.stringify(data,null,2)}
      </div>
        <LogOutButton/>
    </div>
  )
}

export default Home ;
```


# Adding Protected Procedures in TRPC

init.ts (src/trpc/init.ts)
-------

```tsx
export const protectedProcedure = baseProcedure.use(async({ ctx , next}) => {
  // check if the user is signed in
  const session  = await auth.api.getSession({
    headers : await headers()
  }) ;

  if(!session){
    throw new TRPCError({
      code : 'UNAUTHORIZED',
      message : 'User is not authenticated' 
    })
  }
  return next({ ctx : {...ctx , auth : session }}) ; 
```


# .query() vs .mutation()

* .query() -> Fetch/read data without changing anything
* .mutation() -> create / update / delete data

```ts
export const appRouter = createTRPCRouter({
  getWorkFlows : protectedProcedure.query(({ctx}) => {     
      return pClient.workflow.findMany();
  }), 
  createWorkFlow : protectedProcedure.mutation(() => {    
     return pClient.workflow.create({
        data : {
          name : "test-workflow"
        }
     })
  }),
});
// export type definition of API
export type AppRouter = typeof appRouter;
```


* These tanstack react query hooks are used in client component and can execute the promises

-> useQuery for .query()  
-> useMutation for .mutation()

page.tsx (src/app/page.tsx)
--------
```tsx
"use client" ;

import { Button } from "@/components/ui/button";
import { LogOutButton } from "./logout";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useTRPC } from "@/trpc/client";

const Home = () => {
    const  trpc = useTRPC() ; 
    const { data } = useQuery(trpc.getWorkFlows.queryOptions()) ;

    const queryClient = useQueryClient() ; 
    const create = useMutation(trpc.createWorkFlow.mutationOptions({
      onSuccess : () => {
        queryClient.invalidateQueries(trpc.getWorkFlows.queryOptions()) ;  // refetchs data/worklow in case of successul creation
      }
    })) ;

  return (
    <div className="min-h-screen min-w-screen flex items-center justify-center flex-col gap-y-6">
      protected server component
      <div>
        {JSON.stringify(data,null,2)}
      </div>
      <Button disabled={create.isPending} onClick={ () => create.mutate() }>
        Create workflow
      </Button>

      <LogOutButton/>
    </div>
  )
}

export default Home ;
```


# BackGround Jobs

1) Invoking background job through inngest by code 

* using .send() method 

```tsx
    await inngest.send({
      name : "test/hello.world" ,    // event name 
      data : {
        email : "test1123gmail.com"
      },
    }) ;

```

**NOTE** : can be done manually from inngest dashboard

# Using skd-ai services with inngest 

```ts
import { inngest } from "./client";
import { google } from '@ai-sdk/google';
import { openai } from '@ai-sdk/openai';
import { anthropic } from "@ai-sdk/anthropic";
import { generateText } from 'ai';

export const execute = inngest.createFunction(
  { id: "math" },
  { event: "testAI/sum" },
  async ({ event, step }) => {

      // Gemini
      const {steps : geminiSteps} = await step.ai.wrap("gemini-generate-text", 
        generateText , {
          model : google("gemini-2.5-flash") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?"
        }
      ) ; 

      // OpenAI
      const {steps : openaiSteps} = await step.ai.wrap("openai-generate-text", 
        generateText , {
          model : openai("gpt-5") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?"
        }
      ) ; 

      // Anthropic
      const {steps : anthropicSteps} = await step.ai.wrap("anthropic-generate-text", 
        generateText , {
          model : anthropic("claude-sonnet-4-5") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?"
        }
      ) ; 

      return { geminiSteps , openaiSteps , anthropicSteps}  ; 
  },
);  
```


# Error Tracking with Sentry in NextJs

* AI Montoring with Sentry using Vercel AI SDK integration (https://docs.sentry.io/platforms/javascript/guides/nextjs/configuration/integrations/vercelai/)

sentry.server.config.ts
-----------------------
```tsx
import * as Sentry from "@sentry/nextjs";
Sentry.init({
  dsn: "https://4826807a00bcb4d7d984e794bcde509c@o4510702096089088.ingest.de.sentry.io/4510702120075344",
  integrations: [
    Sentry.vercelAIIntegration({
      recordInputs: true,
      recordOutputs: true,
    }),
  ],
  tracesSampleRate: 1,
  enableLogs: true,
  sendDefaultPii: true,
});
```

-> Add this to the generated Text
```tsx
experimental_telemetry : {
  isEnabled: true,
  recordInputs: true,
  recordOutputs: true,
}
```

function.ts
-----------
```tsx
import { inngest } from "./client";
import { google } from '@ai-sdk/google';
import { openai } from '@ai-sdk/openai';
import { anthropic } from "@ai-sdk/anthropic";
import { generateText } from 'ai';

export const execute = inngest.createFunction(
  { id: "math" },
  { event: "testAI/sum" },
  async ({ event, step }) => {
      const {steps : geminiSteps} = await step.ai.wrap("gemini-generate-text", 
        generateText , {
          model : google("gemini-2.5-flash") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?",
          experimental_telemetry : {
            isEnabled: true,
            recordInputs: true,
            recordOutputs: true,
          },  
        }
      ) ; 

      
      const {steps : openaiSteps} = await step.ai.wrap("openai-generate-text", 
        generateText , {
          model : openai("gpt-5") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?",
          experimental_telemetry : {
            isEnabled: true,
            recordInputs: true,
            recordOutputs: true,
          },
        }
      ) ; 

      const {steps : anthropicSteps} = await step.ai.wrap("anthropic-generate-text", 
        generateText , {
          model : anthropic("claude-sonnet-4-5") , 
          system : "You are an helpful assistant" , 
          prompt : "What is 2 + 2 ?",
          experimental_telemetry : {
            isEnabled: true,
            recordInputs: true,
            recordOutputs: true,
          },
        }
      ) ; 
      
      return { geminiSteps , openaiSteps , anthropicSteps}  ;

  },
);  
```

* Add logging (https://docs.sentry.io/platforms/javascript/guides/nextjs/logs/)


# Accessing Dynamic Route Params in NextJs Server Component

page.tsx (src/app/(dashboard)/(rest)/credentials/[credentialId]/page.tsx)
--------

```tsx
interface pageProps {
    params : Promise<{ credentialId: string }>;  // credentailId should be the name cause we want access that param 
}

const Page = async({ params }: pageProps) => {
    const { credentialId } = await params;
    return (
        <div>
            Credentials Id : {credentialId}
        </div>
    ); 
}

export default Page;
```

# How to setup Payments using Polar with Better-Auth

1) create polarClient 

polar.ts (src/lib/polar.ts)
--------
```ts
import { Polar } from "@polar-sh/sdk" ; 

export const polarClient = new Polar({
    accessToken : process.env.POLAR_ACCESS_TOKEN ,
    server : (process.env.NODE_ENV !== "production") ? "sandbox" : "production" // TODO : change in production
}) ;
```

2) Add polar plugin to better-auth


auth.ts (src/lib/auth.ts)
--------

```ts
import { checkout , polar , portal } from "@polar-sh/better-auth";
import { betterAuth, check } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import   pClient from "./db";
import { polarClient } from "./polar";

export const auth = betterAuth({
    database: prismaAdapter(pClient, {
        provider: "postgresql", // or "mysql", "postgresql", ...etc
    }),
    emailAndPassword : {
        enabled: true , 
        autoSignIn : true , // automatically sign in users after user register/sign up
    },
    plugins : [
        polar({
            client: polarClient,
            createCustomerOnSignUp: true,   // this field creates a customer in polar dashboard whenever a user signs up in our app
            use: [
                checkout({
                    products: [
                        {
                            productId: "xyz",
                            slug: "pro" // Custom slug for easy reference in Checkout URL, e.g. /checkout/n8n-clone-dev 
                                        // slug is like a nickname of product
                        }
                    ],
                    successUrl: process.env.POLAR_SUCCESS_URL,
                    authenticatedUsersOnly: true
                }),
                portal() 
            ],
        })
    ]
});
```

**createCustomerOnSignUp** -> this field creates a customer in polar dashboard whenever a user signs up in our app


auth-client.ts (src/lib/auth-client.ts)
--------------

```ts
import { polarClient } from "@polar-sh/better-auth"
import { createAuthClient } from "better-auth/react"
export const authClient = createAuthClient({
    plugins : [polarClient()] ,
})
```

* Now the user will be created automatically in polar when they sign up

3) How to upgrade to *Pro* tier using polar ?  

* Add this in 
app-sidebar.tsx (src/components/app-sidebar.tsx)
---------------

```tsx
  onClick={() => { authClient.checkout( {slug : "pro"} )}}   // to add pro tier thorugh polar
```

* This will lead the user to polar payment screen 

**NOTE** : 
*You can also allow trail period for pro tier from polar dashboard while or after creating the product by going to product -> edit product -> enable trial period*


4) Testing Payments
**If you want to test payement then you can use stripe test cards**

Stripe Test Card no : 4242 4242 4242 4242
Expiration : Any future date
CVC : any 3 digits code 
contry : any valid country


5) To know the subscription tier *(base or pro tier)* of user

// this function will give subscription state of user i.e base or pro tier
* const { data } = await authClient.customer.state() ;   


use-subscription.ts (src/features/subscriptions/hooks/use-subscriptions.ts)
-------------------
```ts
import { useQuery } from '@tanstack/react-query';
import { authClient } from '@/lib/auth-client' ;

export const useSubscriptions = () => {
    return useQuery({
        queryKey : ['subscriptions'] ,
        queryFn  : async() => {
            const { data } = await authClient.customer.state() ;  // will give subscription state of user i.e base or pro tier
            return data ;  
        } 
    })
}


export const useHasActiveSubscription = () => {
    const { data : customerState , isLoading  , ...rest} = useSubscriptions() ; 
    console.log(customerState) ; 
    const hasActiveSubscriptions = customerState?.activeSubscriptions && customerState.activeSubscriptions.length > 0  // user can have more than one active subscription

    return {
        hasActiveSubscriptions ,
        subscription : customerState?.activeSubscriptions?.[0],
        isLoading,
        ...rest
    } 
}
```

6) To add the polar billing portal
* Add this in 
app-sidebar.tsx (src/components/app-sidebar.tsx)
---------------
```tsx
  onClick={() => authClient.customer.portal() }  // to add the polar billing portal
```

7) Creating a premium procedure in TRPC

init.ts (src/trpc/init.ts)
-------
```ts 
import { auth } from '@/lib/auth';
import { polarClient } from '@/lib/polar';
import { TRPCError } from '@trpc/server';

export const premiumProcedure = protectedProcedure.use(async({ctx , next}) => {
  const customer = await polarClient.customers.getStateExternal({
    externalId : ctx.auth.user.id
  })

  if(!customer.activeSubscriptions || customer.activeSubscriptions.length === 0){
    throw new TRPCError({
    code : "FORBIDDEN",
    message : "Active subscription required"
    })
  }
  return next({ ctx : { ...ctx , customer }}) ;
})
```


# Adding NUQS for param handling 

1) Add NuqsAdapter in layout.tsx

layout.tsx (src/app/layout.tsx)
----------

```tsx
import { TRPCReactProvider } from "@/trpc/client";
import { Toaster } from "sonner";
import { NuqsAdapter } from "nuqs/adapters/next/app"

/*
....
*/

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`} >
        <TRPCReactProvider>
          <NuqsAdapter>
          {children}
          <Toaster/>
          </NuqsAdapter>
        </TRPCReactProvider>
      </body>
    </html>
  );
```


# Creating Debouncer for SeachParams in URL 

use-entity-search.ts (src/hooks/use-entity-search.ts)
--------------------

```tsx
import { useEffect , useState } from "react"
import { PAGINATION } from "@/config/constants"

interface UseEntitySearchProps <T extends {  // T is a generic type parameter that is constrained to have at least those 2 properties. 
    search : string , 
    page   : number
}>{
    params : T ;
    setParams : (params : T) => void ;
    debounceMs? : number ;
}


/*
 the current timeout will always be cleared before the next re-render even if it's callback is not called yet

 if (the next re-render happens before decounceMs time)
 then "callback will not be called" 
 else "callback will be called" .

 thus this works as a debouncer 
*/

export function useEntitySearch<T extends {  // debounce the search input to avoid too many updates
search : string , 
page   : number
}>({
    params,
    setParams,
    debounceMs = 500 ,
}: UseEntitySearchProps<T>){
    const [localSearch,setLocalSearch] = useState(params.search) ;

    useEffect(() =>{
        if(localSearch === "" && params.search !== ""){
            setParams({
                ...params,
                search : "",
                page : PAGINATION.DEFAULT_PAGE
            })
            return ; 
        }
        
        const timer = setTimeout(() =>{
            if(localSearch !== params.search){
                setParams({
                    ...params,
                    search : localSearch,
                    page : PAGINATION.DEFAULT_PAGE
                })
            } 
        },debounceMs) ;

        return () => clearTimeout(timer) ;
    },[localSearch, params, setParams, debounceMs]) ;

    useEffect(() =>{
        setLocalSearch(params.search) ;
    },[params.search]) ;

    return {
        searchValue : localSearch,
        onSearchChange : setLocalSearch
    }
} 
```


# OnBlur property of Input Tag

-> onBlur fires when the input loses focus, which happens when you click outside the input box (or tab away from it) .
* i.e if you click outside the input box onBlur get triggered

editor-header.tsx (src/features/editor/components/editor-header.tsx)
-----------------

```tsx
export const EditorNameInput = ( { workflowId } : { workflowId: string } ) =>{
    const { data : workflow } = useSuspenseWorkflow(workflowId) ;
    const updateWorkflow = useUpdateWorkflowName() ; 

    const [isEditing, setIsEditing] = useState(false) ;
    const [name, setName] = useState(workflow.name) ;

    const inputRef = useRef<HTMLInputElement>(null) ;

    useEffect(() =>{
        if(workflow.name){
            setName(workflow.name) ;
        }
    },[workflow.name]) ;

    useEffect(() =>{
        if(isEditing && inputRef.current){
            inputRef.current.focus() ;
            inputRef.current.select() ;
        }
    },[isEditing]) ;

    const handleSave = async() =>{
        if(name == workflow.name){
            setIsEditing(false) ;
            return ;
        }

        try{
            await updateWorkflow.mutateAsync({
                id : workflowId,
                name : name
            }) ;
        }
        catch{
            setName(workflow.name) ;
        }
        finally{
            setIsEditing(false) ;
        }
    }

    const handleKeyDown = (e : React.KeyboardEvent) =>{
        if(e.key === "Enter"){
            handleSave() ;
        }
        else if(e.key === "Escape"){
            setName(workflow.name) ;
            setIsEditing(false) ;
        }
    }

    if(isEditing){
        return (
            <Input
                ref={inputRef}
                value={name}
                onChange={(e) => setName(e.target.value)}
                onBlur={handleSave}
                onKeyDown={handleKeyDown}
                className="h-7 w-auto min-w-[100px] px-2"
            >

            </Input>
        )
    }

    return (
        <BreadcrumbItem 
            onClick={() => setIsEditing(true)}
            className="cursor-pointer hover:text-foreground transition-colors"
        >
            {workflow.name}
        </BreadcrumbItem>
    )
}
```